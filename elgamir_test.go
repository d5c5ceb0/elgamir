package elgamir

import (
	"math/big"
	mrand "math/rand"
	"testing"
	"time"
)

func TestElgamir(t *testing.T) {
	para, dealer, shares := setup(2, 100, 10)
	r := mrand.New(mrand.NewSource(time.Now().UnixNano()))
	msg := new(big.Int).Rand(r, para.ElgamalQ)
	c, ret := testEncrypt(para, msg.Bytes(), shares)
	if ret != nil {
		t.Errorf("encrypt error.")
		return
	}
	m := testDecrypt(para, c, dealer.privKeyShare)
	if msg.Cmp(new(big.Int).SetBytes(m)) != 0 {
		t.Errorf("not equal.")
		return
	}
	if testing.Short() {
		return
	}
}

func BenchmarkElgamir(b *testing.B) {
	b.ResetTimer()
	para, dealer, shares := setup(256, 100, 10)
	r := mrand.New(mrand.NewSource(time.Now().UnixNano()))
	msg := new(big.Int).Rand(r, para.ElgamalQ)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		c, _ := testEncrypt(para, msg.Bytes(), shares)
		testDecrypt(para, c, dealer.privKeyShare)
	}
}

func setup(keylen, N, n int) (ElgamalPara, KeyShare, []PubKeyShare) {
	r := mrand.New(mrand.NewSource(time.Now().UnixNano()))
	//	para, _ := Setup(keylen)
	para := ElgamalPara{}
	para.ElgamalP, _ = new(big.Int).SetString("28706579328304107441157390960522516745991328987267169907213238450202556097050268798931456180029000306395920868596709135397849226662813103502469766662758538110975099501099052626153653451212433856686668297636228101951175623648962902359899151779811654298227306927301177760981527404883586478179201056326998695026626273983096328388390121895455142569756309313343662916200070757320147700110739019605524602059258364589574081170904741560685444345267738234723219200159596710232461473008859111244479445417890841916489644861189868796991588594738043928870199236401834835729554321765924198333617759270240215068784940659854030879563", 10)
	para.ElgamalG, _ = new(big.Int).SetString("14009101129438775102184556184153012228558421520025637101641843300958316362751565259685156962131597104772165464054598383826555070507993549230873097420101869952655612727656037655228637493720110211155695533759046221097415505806959605718942056919707332893772880626702656932581522488192647146234300229364851314962898715236308569194498729907621456800882827547995224799553713308544518886608541782289554230872263846805522260454561978123848243623169285015904556573134807040851325561204048280366304397250706170527830779313939951673370322645217788249244407660281011694858047372355624011098642693715667920742960934800525133037161", 10)
	para.ElgamalQ, _ = new(big.Int).SetString("14353289664152053720578695480261258372995664493633584953606619225101278048525134399465728090014500153197960434298354567698924613331406551751234883331379269055487549750549526313076826725606216928343334148818114050975587811824481451179949575889905827149113653463650588880490763702441793239089600528163499347513313136991548164194195060947727571284878154656671831458100035378660073850055369509802762301029629182294787040585452370780342722172633869117361609600079798355116230736504429555622239722708945420958244822430594934398495794297369021964435099618200917417864777160882962099166808879635120107534392470329927015439781", 10)
	AllShares := make([]KeyShare, 0)
	for k := 1; k <= N; k++ {
		AllShares = append(AllShares, para.ShareKeyGen(big.NewInt(int64(UserIdx+k))))
	}

	dealer := AllShares[r.Intn(N)]
	shares := make([]PubKeyShare, 0)
	shares = append(shares, dealer.PubKeyShare)
	for {
		index := r.Intn(N)
		for x, share := range shares {
			if share.X.Cmp(AllShares[index].PubKeyShare.X) == 0 {
				break
			}
			if (x + 1) == len(shares) {
				shares = append(shares, AllShares[index].PubKeyShare)
			}
		}
		if len(shares) == n {
			break
		}
	}

	return para, dealer, shares
}

func testEncrypt(para ElgamalPara, msg []byte, shares []PubKeyShare) (ElCipher, error) {
	c, err := para.Encrypt(shares, msg)
	if err != nil {
		return ElCipher{}, err
	}
	return c, nil
}

func testDecrypt(para ElgamalPara, c ElCipher, shares privKeyShare) []byte {
	m := para.Decrypt(shares, c)
	return m
}
